/* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */


options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Parser)

import java.util.Scanner;

import java.io.InputStream;
import java.io.ByteArrayInputStream;

import java.nio.charset.StandardCharsets;

/** Simple brace matcher. */
public class Parser {
  
  public interface Expression {
	 public void interpret(Object context);
	 public int asIntValue(Object context);
	 public String  asStringValue(Object context);
  }
  
   public class ProxyExpression implements Expression {
	 private Expression expr = null;
	 public ProxyExpression(Expression expression) {
		expr = expression;
	 }
	 public void interpret(Object context) {
		expr.interpret(context);
	 }
	 
	  public int asIntValue(Object context) {
		interpret(context);
		return expr.asIntValue();
	  }
	  
	  public String asStringValue() {
		return "" + asIntValue();
	  }
  }
  
  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
    
		Parser parser = new Parser(readInput());
		try {
			parser.parseTerm();
		} catch( Exception ex ) {
			System.out.println(ex.getMessage());
		}
  }
  
  public static InputStream readInput() {
	StringBuffer strBuffer = new StringBuffer();
	Scanner sc = new Scanner(System.in);
	while(sc.hasNextLine()) {
		String line = sc.nextLine(); 
		if(line.length() == 0) break;
		strBuffer.append(line);
		strBuffer.append(System.getProperty("line.separator"));
	}
	String input = strBuffer.toString();
	return new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));
  }
}

PARSER_END(Parser)

/** Skip Tokens **/

SKIP : {
	" "
| 	"\t"
| 	"\n"
| 	"\r"
}

/** Default Tokens **/

TOKEN : {
	<NUMBER_LITERAL: (<DIGIT>)+ ("."( <DIGIT> )+ )?  >
|	<VARNAME: ( <LETTER> ( <LETTER> | <DIGIT> )* ) >
|	<LETTER: ["a" - "z", "A" - "Z", "_"]> 
|	<DIGIT: ["0" - "9"]>
|	<LRBRACE: "(">
|	<RRBRACE: ")">
|	<LSBRACE: "[">
|	<RSBRACE: "]">
|	<PLUS: "+" > 
| 	<MINUS: "-" > 
| 	<TIMES: "*" > 
| 	<DIVISION: "/" >
}

/** Root production. */
Expression parseTerm() :
{
	Expression term = null;
}
{
  term = TERM() <EOF> { return new ProxyExpression(term); }
}

/** Root production. */
Expression TERM() :
{}
{
  OPERAND() (OPERATOR() OPERAND())* {return null;}
}

void OPERATOR() : 
{}
{
	<PLUS>
|
	<MINUS>
|
	<TIMES>
|	
	<DIVISION>
}


void OPERAND() :
{}
{
	
	MATRIX_LITERAL()
|
	LOOKAHEAD(2)
	FUNCTION()
| 	
	<NUMBER_LITERAL> 
| 	
	<VARNAME> 
}

void MATRIX_LITERAL() :
{}
{
	<LSBRACE> ( <LSBRACE> ARGUMENT_LIST() <RSBRACE> )+ <RSBRACE>
}

void FUNCTION() : 
{}
{
	<VARNAME><LRBRACE>[ARGUMENT_LIST()]<RRBRACE>
}

void ARGUMENT_LIST() :
{}
{
	TERM() ( "," TERM())* 
}



